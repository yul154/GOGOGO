# 程序结构
* 命名
* 声明
* 变量
* 赋值
* 类型
* 包和文件
* 作用域

----

## 命名
Go语言中遵循命名规则
* 一个名字必须以一个字母（Unicode字母）或下划线开头
* 大写字母和小写字母是不同的
* 如果一个名字是在函数内部定义，那么它就只在函数内部有效
* 名字的开头字母的大小写决定了名字在包外的可见性。
  * 如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问
* 包本身的名字一般总是用小写字母。

---
## 声明
> 声明语句定义了程序的各种实体对象以及部分或全部的属性

Go语言主要有四种类型的声明语句：
1. var
2. const
3. type
4. func

go文件顺序
1. 每个源文件中以包的声明语句开始，说明该源文件是属于哪个包
2. 包声明语句之后是import语句导入依赖的其它包
3. 包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要


一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选的返回值列表和包含函数定义的函数体组成
```
func fToC(f float64) float64 {
    return (f - 32) * 5 / 9
}
```
---
## 变量
```
var 变量名字 类型 = 表达式
```
其中“类型”或“= 表达式”两个部分可以省略其中的一个
* 如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。
* 如果初始化表达式被省略，那么将用零值初始化该变量

go基础类型的初始值
* 数值类型变量对应的零值是0
* 布尔类型变量对应的零值是false
* 字符串类型对应的零值是空字符串
* 接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil

零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量
```
var s string
fmt.Println(s) 
```
### 简短变量声明
在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量
```
//名字 := 表达式
anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t := 0.0
```

## 指针
一个变量对应一个保存了变量对应类型值的内存空间，一个指针的值是另一个变量的地址。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址
```
x := 1
p := &x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"
```

任何类型的指针的零值都是nil。如果p指向某个有效变量，那么p != nil测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。
```
var x, y int
fmt.Println(&x == &x, &x == &y, &x == nil) 
```

### new函数
表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T
```
p := new(int)   // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p) // "0"
*p = 2          // 设置 int 匿名变量的值为 2
fmt.Println(*p) // "2"
```

每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的：
```
p := new(int)
q := new(int)
fmt.Println(p == q) // "false"
```

### 变量的生命周期
对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的

局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收
* 函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建

Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢
* 因为一个变量的有效周期只取决于是否可达
* 基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量

----
## 赋值
```
x = 1                       // 命名变量的赋值
*p = true                   // 通过指针间接赋值
person.name = "bob"         // 结构体字段赋值
count[x] = count[x] * scale // 数组、slice或map的元素赋值
```
### 元组赋值
> 允许同时更新多个变量的值
```
x, y = y, x

a[i], a[j] = a[j], a[i]
```

在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值

```
func gcd(x, y int) int {
    for y != 0 {
        x, y = y, x%y
    }
    return x
}

func fib(n int) int {
    x, y := 0, 1
    for i := 0; i < n; i++ {
        x, y = y, x+y
    }
    return x
}
```

### 可赋值性
函数调用会隐式地将调用参数的值赋值给函数的参数变量
* 一个返回语句会隐式地将返回操作的值赋值给结果变量
* 一个复合类型的字面量（§4.2）也会产生赋值行为

```
medals := []string{"gold", "silver", "bronze"}
```

可赋值性的规则对于不同类型有着不同要求，对每个新类型特殊的地方我们会专门解释。对于目前我们已经讨论过的类型，它的规则是简单的：
* 类型必须完全匹配
* `nil`可以赋值给任何指针或引用类型的变量
* 对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系
---
## 类型
```
type 类型名字 底层类型
```
类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用

```
package tempconv

import "fmt"

type Celsius float64    // 摄氏温度
type Fahrenheit float64 // 华氏温度

const (
    AbsoluteZeroC Celsius = -273.15 // 绝对零度
    FreezingC     Celsius = 0       // 结冰点温度
    BoilingC      Celsius = 100     // 沸水温度
)

func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
```
---
## 包和文件

包可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息
* 如果一个名字是大写字母开头的，那么该名字是导出的

---
## 作用域

声明语句的作用域是指源代码中可以有效使用这个名字的范围

* 声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。
* 一个变量的生命周期是指程序运行时变量存在的有效时间段

句法块是由花括弧所包含的一系列语句
* 句法块内部声明的名字是无法被外部块访问的

语法块：在代码中并未显式地使用花括号包裹起来
* 存在一个整体的词法块，称为全局词法块；
  * 对于每个包；每个for、if和switch语句，也都有对应词法块；
  * 每个switch或select的分支也有独立的词法块；当然也包括显式书写的词法块
